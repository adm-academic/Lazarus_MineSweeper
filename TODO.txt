=== Первый Этап. [+] ЗАВЕРШЁН !
1. Статичное игровое поле заданного размера, оно никак не изменяется,
   размеры и мины заданы константами. [+]
2. Нет настроек игры, нет подсчёта времени, нет списка лучших игроков [+]
3. Только игровое поле и основной геймплей с минами...  [+]

- I. создать типы данных для отдельных ячеек [+]
- II. создать массивы для нижней и верхней игровой матрицы [+]
- III. применить DrawGrid для игры, натсроить его первоначально. [+]
- IV. Для начала не использовать спрайты в DrawGrid, а выводить ячейки
     простым текстом. [+]
- V. Первичная инициализация массивов верхней и нижней игровой сетки. [+]
- VI. Согласованая работа и отображение нижней и верхней
      игровых матриц.  [+]
- VII. Рекурсивное открытие пустых ячеек   [+]
- VIII. Подсчёт числа соседних мин [+]
- IX. Показ числа соседних мин [+]
- X. Показ всех типов ячеек   [+]
- XI. Установка и снятие флагов [+]
- XII. Обработка подрыва на мине [+]
- XIII. Простейшая реализация состояний игры  и их отображение  [+]
- XIV. Распознавание прогрыша и показ игроку: [+]
- XV. Раздобыть и применить ассеты для отображения ячеек в DrawGrid. [+]

- XVI. Поддержка разных наборов асетов, чтобы можно было менять оформление выбором
       папки с асетами во время игры. А для этого нужно разработать и запрограммировать
       свой отдельный объект, можно не синглтон, который и должен отвечать за
       подгрузку с диска ассетов, умное кеширование. [+-]
       ( окончательно класс ассетов станет ясен только после разработки интерфейса
         к "Сапёру", на первом этапе готово только игровое поле. )

- XVII. Рефакторинг кода с выделением всей логики игры в отдельный модуль,
        оформление этого кода как отдельного класса. При создании которого передавать
        в конструктор Create ссылки на игровую форму, игровой DrawGrid,
        лэйбл для отображения состояния игры  [+]

- XVIII. Распознавание выигрыша/проигрыша и показ игроку: [+]

- XIX. На первом ходе игрок не подрывается, мина переносится в свободную ячейку [+]

- XX. Реализовать аккорды, то есть автоматическое открытие ячеек с учётом
      выставленых флагов по одновременному клику двумя клавишами мышки [+]

- XXI. При рекурсивном открытии ячеек методом open_cell флаги раскрываться не должны ! [+]

- XXII. В игровом коде все переборы соседних ячеек сделать через цикл по "square_offsets" [+]

- XXIII. Реакция на мышь сделана не по нажатию (OnMouseDown), а по отпусканию (OnMouseUp) [+]

- XIV.  Поправить код логики T_Mine_Sweeper чтобы работали любые размерности N:M, сейчас
        из-за бажного легаси-кода в логике при некоторых размерностях перестают открываться
        и обрабатываться ячейки. [+]

________________________________________________________________________________



=== Второй  Этап. [ ++-- ]
- I. Сделать форму "О Программе". [+]

- II. Сделать форму "О Lazarus". [+]

- III. Сделать форму "Начать игру". [+]

- IV. Интерактивность главной формы с сеткой "Сапёра" сделать как в  [+]
        реализации KMines из состава KDE Games. Для этого:
         * вынести дро-грид на отдельную панель
         * у этой панели задать BorderSpacing
         * реализовать метод function get_form_current_tile_size : integer;, который
           определяет размер тайла в зависимости от текущего размера формы и игровой панели,
           таким образом, чтобы игровой грид равномерно заполнил игровую панель по
           минимальной стороне последней.
         * в T_Mine_Sweeper добавить метод procedure resize_game_grid(new_tile_size: integer);
           который перенастраивает игровой грид и перенастраивается сам под новый размер тайла.
         * В главную форму добавить метод FormResize, который будет вызывать
           resize_game_grid и тем самым делать интерфейс адаптивным к размеру форму,
           очень похоже на KMines.
         * При запуске главной формы сразу иницализировать игровой дро-грид
           настройкми из формы f_start_new

- V. Ввести в программу четыре уровня игры: [+]
          - легкий
          - средий
          - сложный
          - кастомный

- VI. Сделать форму "Кастомный уровень сложности". [+]

- VII. Ввести в T_Mine_Sweeper подсчёт времени игры и итогового времени затраченому на партию [+]

- VIII. Ввести в отображение количества установленых мин [+]

- IX.  Ввести в программу подсчёт количества установленых флагов [+]

- X.   Ввести в программу отображение текущего времени игры [+]

- XI. Ввести в T_Mine_Sweeper метод который возвращает длительность текущей игровой партии [+]

- XII.  Нужно добавить коллбэк в T_Mine_Sweeper чтобы в случае победы
        в главной форме добавлять новый рекорд. [+]

- XIII.  При добавлении рекорда нужно вызывать: [+]
           # форму с полем для никнейма и длительностью выигранного матча
           # форму со списком рекордов

- XIII.   Ввести в программу подсчёт рекордов: [+]
       - хранение в файле [+]
       - код-прослойка для доступа к рекордам в файле [+]
       - окно отображения рекордов [+]
       - форма добавления своего имени в рекорды в файле и в окно отображения рекордов [+]

- XIV.  Сделать форму "Рекорды".  [+]

- XV.   Сделать форму "Добавить имя для достигнутого рекорда". [+]

--------------------------------------------------------------------------------

- XVI.  Ввести в программу использование настроек:
        - файл настроек ini для приложения [ --- ]
        - объект настроек, хранящий и читающий или записывающий все настройки игры в файл.  [ --- ]

- XVII.   Cделать форму "Настройки".  [ --- ]

- XVIII.  Ввести в программу звуковые эффекты [ --- ]

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>> В gnome-mines флаги и мины судя по всему векторные, как и все остальные тайлы !!!!!!!!!!!
>>>> В winmine они статичного, но маленького размера
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

- XIX. Модифицировать T_Asset_Pack и сами наборы эссетов так, чтобы была поддержка
         поднаборов эссетов разного разрешения и был автоматический выбор тайлов
         при перерисовке интерфейса. Я вижу это как несколько папок тайлов с разными
         размерами тайлов и выбор тайла с наиболее близким к отрисовываемому разрешением. [ --- ]

________________________________________________________________________________



=== Третий этап.  [ --- ]

- Переносим отрисовку из TDrawGrid на передаваемый объект, на котором , через буфер TBitmap,
  будут отрисовываться на его TCanvas игра "Сапёр". Передаваемый объект может быть TPanel,
  TImage, возможно ещё какой-то, но это явно не форма, так как у этого объекта
  класс T_Mine_Sweeper переопределяет много обработчиков событий. Это нужно
  для более простого переноса игры в Delphi VCL и Delphi FMX. [ --- ]

- Перенос логики в Delphi FMX.  [ --- ]

- Запрограммировать интерфейс игры с учётом тачскрин-геймплея. [ --- ]

- Выпустить игру под Android. [ --- ]
- Выпустить игру под Apple IOS. [ --- ]
- Выпустить игру под Apple MacOS [ --- ]



